generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// NextAuth Required Models
model User {
  id             String          @id @default(uuid())
  name           String?
  email          String?         @unique
  emailVerified  DateTime?
  image          String?
  password       String? // For credentials auth
  role           String          @default("user") // user | admin
  // Optional contact info fields
  firstName      String?
  lastName       String?
  phone          String?
  address1       String?
  address2       String?
  city           String?
  region         String? // Province/State (e.g., "ON")
  postalCode     String?
  country        String? // Default "CA" if you want
  accounts       Account[]
  sessions       Session[]
  devices        Device[]
  lists          List[]
  savedLists     SavedList[]     @relation("SavedLists") // Saved list snapshots
  identityClaims IdentityClaim[] // Retroactive attribution audit
  preference     UserPreference? // NFC landing preference
  linkedNfcTags  NfcTag[]        @relation("LinkedNfcTags") // Tags linked to this user
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  @@index([region])
  @@index([postalCode])
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Device Identity
model Device {
  id        String   @id @default(uuid())
  deviceId  String   @unique // UUID stored in client localStorage/cookie
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  lists     List[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Grocery List
model List {
  id            String     @id @default(uuid())
  name          String     @default("My Groceries")
  ownerUserId   String?
  ownerUser     User?      @relation(fields: [ownerUserId], references: [id], onDelete: SetNull)
  ownerDeviceId String?
  ownerDevice   Device?    @relation(fields: [ownerDeviceId], references: [id], onDelete: SetNull)
  pinLookup     String?    @unique // sha256(pin + pepper) for lookup
  pinHash       String? // bcrypt hash for verification
  isArchived    Boolean    @default(false)
  items         ListItem[]
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
}

// Categories
model Category {
  id        String        @id @default(uuid())
  name      String        @unique
  sortOrder Int           @default(0)
  items     GroceryItem[]
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
}

// Grocery Items (master list)
model GroceryItem {
  id              String           @id @default(uuid())
  name            String
  categoryId      String
  category        Category         @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  icon            String? // emoji or lucide icon name
  cuisine         String?          @db.VarChar(64) // optional cuisine filter (e.g., "indian", "jamaican", "mexican")
  isActive        Boolean          @default(true)
  sortOrder       Int              @default(0)
  listItems       ListItem[]
  savedListItems  SavedListItem[]
  productVariants ProductVariant[]
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@unique([name, categoryId])
}

// Stores
model Store {
  id        String           @id @default(uuid())
  name      String           @unique
  logo      String? // URL to store logo
  variants  ProductVariant[]
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
}

// Product Variants (store-specific products)
model ProductVariant {
  id            String      @id @default(uuid())
  groceryItemId String
  groceryItem   GroceryItem @relation(fields: [groceryItemId], references: [id], onDelete: Cascade)
  storeId       String
  store         Store       @relation(fields: [storeId], references: [id], onDelete: Cascade)
  name          String // e.g., "Red Apple" or "Organic Red Apple"
  imageUrl      String? // URL to product image
  price         Float? // Optional price
  barcode       String?     @unique // Barcode (EAN/UPC) from OpenFoodFacts
  listItems     ListItem[]
  savedListItems SavedListItem[]
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@unique([groceryItemId, storeId]) // One variant per item+store pair for upsert
}

// List Items (selected groceries)
model ListItem {
  id               String          @id @default(uuid())
  listId           String
  list             List            @relation(fields: [listId], references: [id], onDelete: Cascade)
  groceryItemId    String
  groceryItem      GroceryItem     @relation(fields: [groceryItemId], references: [id], onDelete: Cascade)
  productVariantId String? // Optional: specific store product
  productVariant   ProductVariant? @relation(fields: [productVariantId], references: [id], onDelete: SetNull)
  active           Boolean         @default(true) // true = in cart, false = bought/removed
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  @@unique([listId, groceryItemId, productVariantId])
}

// Saved Lists (snapshots for "Save for later" feature)
model SavedList {
  id          String          @id @default(uuid())
  ownerUserId String // required - only logged-in users can save
  ownerUser   User            @relation("SavedLists", fields: [ownerUserId], references: [id], onDelete: Cascade)
  title       String          @default("Grocery Run")
  items       SavedListItem[]
  createdAt   DateTime        @default(now())

  @@index([ownerUserId])
}

// Saved List Items
model SavedListItem {
  id            String     @id @default(uuid())
  savedListId   String
  savedList     SavedList  @relation(fields: [savedListId], references: [id], onDelete: Cascade)
  groceryItemId String
  groceryItem   GroceryItem @relation(fields: [groceryItemId], references: [id], onDelete: Cascade)
  productVariantId String? // Optional: specific store product
  productVariant   ProductVariant? @relation(fields: [productVariantId], references: [id], onDelete: SetNull)

  @@unique([savedListId, groceryItemId])
}

// ═══════════════════════════════════════════════════════
// NFC Tag Analytics + My List System
// ═══════════════════════════════════════════════════════

// NFC Tag Batches (campaign grouping)
model TagBatch {
  id          String            @id @default(uuid())
  slug        String            @unique // e.g. "homedepot-2026-q1"
  name        String // e.g. "Home Depot Q1 2026"
  description String?
  tags        NfcTag[]
  tapEvents   TapEvent[]
  dailyStats  DailyBatchStats[] // aggregated daily stats
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
}

// Individual NFC Tags
model NfcTag {
  id           String          @id @default(uuid()) // internal ID
  publicUuid   String          @unique @default(uuid()) // UUIDv4 used in URL (not guessable)
  batchId      String
  batch        TagBatch        @relation(fields: [batchId], references: [id], onDelete: Cascade)
  label        String? // human label like "HD Tag 001"
  status       String          @default("active") // active | disabled
  linkedUserId String? // User who "owns" this tag — all taps attributed to them
  linkedUser   User?           @relation("LinkedNfcTags", fields: [linkedUserId], references: [id], onDelete: SetNull)
  tapEvents    TapEvent[]
  dailyStats   DailyTagStats[] // aggregated daily stats
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  @@index([batchId])
  @@index([linkedUserId])
}

// Tap Events (one row per NFC scan / URL visit)
model TapEvent {
  id               String    @id @default(uuid())
  tagId            String
  tag              NfcTag    @relation(fields: [tagId], references: [id], onDelete: Cascade)
  batchId          String // denormalized for faster queries
  batch            TagBatch  @relation(fields: [batchId], references: [id], onDelete: Cascade)
  occurredAt       DateTime  @default(now())
  ipHash           String? // sha256(ip + SERVER_SALT) — never store raw IP
  userAgent        String?
  acceptLanguage   String?
  referer          String?
  deviceHint       String? // "mobile" | "desktop" | "tablet"
  anonVisitorId    String? // localStorage ID if available
  sessionHint      String? // short-lived dedupe key
  country          String?
  region           String?
  isDuplicate      Boolean   @default(false)
  duplicateOfId    String? // references original TapEvent.id if this is a dupe
  visitorId        String?
  visitor          Visitor?  @relation(fields: [visitorId], references: [id], onDelete: SetNull)
  // Retroactive attribution fields
  userId           String? // denormalized for fast queries (linked to User when claimed)
  linkedAt         DateTime? // when this tap was attached to a user
  linkMethod       String? // "tag_linked" | "session" | "anonVisitorId" | "recentTapSession" | "ipUaHeuristic"
  tapperHadSession Boolean   @default(false) // true if the person who tapped had an active session (signed in)
  createdAt        DateTime  @default(now())

  @@index([batchId])
  @@index([tagId])
  @@index([anonVisitorId])
  @@index([occurredAt])
  @@index([ipHash, userAgent])
  @@index([userId]) // for user queries
  @@index([tagId, occurredAt]) // compound: per-tag daily aggregation
  @@index([batchId, occurredAt]) // compound: per-batch daily aggregation
}

// Anonymous Visitors (NFC tappers tracked via localStorage ID)
model Visitor {
  id                String          @id @default(uuid())
  anonVisitorId     String          @unique // random UUID from localStorage
  firstSeenAt       DateTime        @default(now())
  lastSeenAt        DateTime        @default(now())
  tapCount          Int             @default(0)
  lastTagId         String? // last NFC tag tapped (for attribution)
  lastBatchId       String? // last batch (for attribution)
  // Retroactive attribution fields
  userId            String?         @unique // links Visitor to User account when claimed
  ipHashLastSeen    String? // track last seen IP hash
  userAgentLastSeen String? // track last seen user agent
  tapEvents         TapEvent[]
  myLists           MyList[]
  identityClaims    IdentityClaim[] // audit trail of claims
  dailyStats        DailyVisitorStats[] // per-visitor daily aggregation
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
}

// My List (shopping list for NFC visitors)
model MyList {
  id             String       @id @default(uuid())
  ownerVisitorId String?
  ownerVisitor   Visitor?     @relation(fields: [ownerVisitorId], references: [id], onDelete: SetNull)
  ownerUserId    String? // optional, if auth exists (same as userId, kept for consistency)
  sourceBatchId  String? // attributed NFC batch
  sourceTagId    String? // attributed NFC tag
  // Retroactive attribution fields
  claimedAt      DateTime? // when this list was claimed by a user
  items          MyListItem[]
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([ownerUserId]) // for user queries
  @@index([ownerUserId, updatedAt]) // compound: user list activity queries
  @@index([createdAt]) // for daily lists-created aggregation
}

// My List Items
model MyListItem {
  id             String    @id @default(uuid())
  listId         String
  list           MyList    @relation(fields: [listId], references: [id], onDelete: Cascade)
  itemKey        String // canonical key like "bananas"
  itemLabel      String // display label like "Bananas"
  quantity       Int?
  lastAddedAt    DateTime  @default(now())
  timesPurchased Int       @default(0)
  purchasedAt    DateTime?
  sourceBatchId  String? // attributed batch for this item add
  sourceTagId    String? // attributed tag for this item add
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@unique([listId, itemKey])
  @@index([itemKey])
  @@index([purchasedAt])
  @@index([lastAddedAt]) // for daily items-added aggregation
}

// Item Catalog (canonical items for MyList)
model ItemCatalog {
  id        String   @id @default(uuid())
  itemKey   String   @unique // canonical key like "bananas"
  label     String // display label like "Bananas"
  emoji     String? // emoji icon
  category  String? // category name
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// User Preferences (NFC landing, etc.)
model UserPreference {
  id             String   @id @default(cuid())
  userId         String   @unique
  nfcLandingMode String   @default("home") // "home" | "list" | "custom"
  nfcLandingPath String? // e.g. "/list" or "/" or custom path
  updatedAt      DateTime @updatedAt
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Identity Claim (audit table for retroactive attribution)
model IdentityClaim {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  visitorId String
  visitor   Visitor  @relation(fields: [visitorId], references: [id], onDelete: Cascade)
  claimedAt DateTime @default(now())
  method    String // "anonVisitorId" | "recentTapSession" | "ipUaHeuristic"
  details   Json? // optional metadata (tapSessionId, ipHash, etc.)

  @@unique([userId, visitorId])
  @@index([userId])
  @@index([visitorId])
  @@index([claimedAt])
}

// Global App Settings (single row with id="global")
model AppConfig {
  id            String   @id @default("global")
  showPriceRange Boolean  @default(true)
  updatedAt      DateTime @updatedAt
}

// ═══════════════════════════════════════════════════════
// Reporting Aggregated Snapshot Tables (write by job only)
// ═══════════════════════════════════════════════════════

// Site-wide daily stats (one row per calendar day)
model DailySiteStats {
  id                String   @id @default(uuid())
  date              DateTime @unique @db.Date // one row per calendar day
  tapsTotal         Int      @default(0)
  uniqueVisitorsEst Int      @default(0) // distinct anonVisitorId + ipHash+UA fallback
  usersNew          Int      @default(0) // new User accounts created that day
  usersActiveEst    Int      @default(0) // unique users/visitors that tapped that day
  listsCreated      Int      @default(0) // MyList rows created that day
  itemsAdded        Int      @default(0) // MyListItem rows added that day
  itemsPurchased    Int      @default(0) // MyListItem rows purchased that day
  updatedAt         DateTime @updatedAt
}

// Per-batch daily stats
model DailyBatchStats {
  id                String   @id @default(uuid())
  date              DateTime @db.Date
  batchId           String
  batch             TagBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  tapsTotal         Int      @default(0)
  uniqueVisitorsEst Int      @default(0)
  signupsAttributed Int      @default(0) // placeholder, set 0 for now
  listsCreated      Int      @default(0)
  itemsAdded        Int      @default(0)
  itemsPurchased    Int      @default(0)

  @@unique([date, batchId])
  @@index([batchId])
}

// Per-tag daily stats
model DailyTagStats {
  id                String   @id @default(uuid())
  date              DateTime @db.Date
  tagId             String
  tag               NfcTag   @relation(fields: [tagId], references: [id], onDelete: Cascade)
  tapsTotal         Int      @default(0)
  uniqueVisitorsEst Int      @default(0)
  updatedAt         DateTime @updatedAt

  @@unique([date, tagId])
  @@index([tagId])
}

// Per-item daily stats (MyListItem aggregation)
model DailyItemStats {
  id             String   @id @default(uuid())
  date           DateTime @db.Date
  itemKey        String // canonical key like "bananas"
  addedCount     Int      @default(0)
  purchasedCount Int      @default(0)
  updatedAt      DateTime @updatedAt

  @@unique([date, itemKey])
  @@index([itemKey])
}

// Per-visitor daily stats (for power user scoring)
model DailyVisitorStats {
  id             String   @id @default(uuid())
  date           DateTime @db.Date // date-only semantics
  visitorId      String
  visitor        Visitor  @relation(fields: [visitorId], references: [id], onDelete: Cascade)
  userId         String?  // nullable; filled when visitor is linked to a user
  taps           Int      @default(0)
  tagsTapped     Int      @default(0)   // distinct tagId count for that date
  batchesTapped  Int      @default(0)   // distinct batchId count for that date
  listsCreated   Int      @default(0)   // if easy to compute; else leave 0 for now
  itemsAdded     Int      @default(0)   // if easy to compute; else leave 0 for now
  itemsPurchased Int      @default(0)   // if easy; else 0
  score          Int      @default(0)
  isPowerUser    Boolean  @default(false)
  updatedAt      DateTime @updatedAt

  @@unique([date, visitorId])
  @@index([date])
  @@index([visitorId])
  @@index([userId])
  @@index([date, score])
}
